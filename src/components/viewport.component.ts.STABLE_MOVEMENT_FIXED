import { Component, input, output, ChangeDetectionStrategy, signal, computed, effect, inject, ChangeDetectorRef } from '@angular/core';
import { CommonModule, NgOptimizedImage } from '@angular/common';
import { GameState, PointOfInterest, DialogueOption, GameCharacter } from '../types';
import { HotspotOverlayComponent } from './hotspot-overlay.component';
import { HotspotArea, BRIDGE_HOTSPOTS, isPointInWalkableArea } from '../scenes/bridge-hotspots';
import { CALIBRATION_HOTSPOTS, isPointInCalibrationWalkableArea } from '../scenes/calibration-hotspots';

@Component({
  selector: 'app-viewport',
  standalone: true,
  imports: [CommonModule, HotspotOverlayComponent],
  changeDetection: ChangeDetectionStrategy.OnPush,
  template: `
    <div class="relative w-full h-full bg-black select-none flex flex-col">
      
      <!-- Loading Overlay -->
      @if (loading()) {
        <div class="absolute inset-0 z-50 flex flex-col items-center justify-center bg-black/90 backdrop-blur-sm text-amber-500">
          <div class="text-5xl animate-spin mb-4">âŸ³</div>
          <div class="animate-pulse tracking-widest text-lg">Loading...</div>
        </div>
      }

      <div class="flex-1 bg-black flex items-center justify-center h-full">
        <!-- Scene Container - Full Screen Mobile -->
        <div class="relative w-full h-full max-h-full max-w-full shadow-2xl transition-transform duration-500" (click)="onSceneClick($event)">
          
          <!-- Scene Background Image - Locked to 16:9 Grid (No Distortion) -->
          @if (imageSrc()) {
            <img [src]="imageSrc()" alt="Scene" class="absolute inset-0 w-full h-full object-cover pixel-sprite">
          } @else {
             <div class="absolute inset-0 flex items-center justify-center p-10 text-center text-slate-700 bg-slate-900">
              <div>
                <div class="text-6xl mb-4 opacity-30">ðŸŽ¬</div>
                <p class="font-serif text-sm italic">Scene Loading...</p>
              </div>
            </div>
          }
          
          <!-- Subtle Vignette (less aggressive) -->
          <div class="absolute inset-0 bg-[radial-gradient(circle,transparent_60%,rgba(0,0,0,0.5)_100%)] pointer-events-none z-10"></div>

          <!-- Hotspot Overlay Layer -->
          @if (!loading() && imageSrc()) {
            <app-hotspot-overlay
              class="absolute inset-0 z-30"
              [gameFlags]="state()?.flags || {}"
              [debugMode]="false"
              [customHotspots]="currentHotspots()"
              (hotspotClicked)="onHotspotInteract($event)"
            ></app-hotspot-overlay>
          }

        <!-- Character Sprites Layer - REAL PIXEL ART SPRITES -->
        @if (!loading()) {
          <div class="absolute inset-0 z-20 pointer-events-none">
            @for (char of state()?.characters; track char.id) {
               <div 
                 class="absolute flex flex-col items-center"
                 [style.left.%]="char.position?.x || 50"
                 [style.top.%]="char.position?.y || 50"
                 [style.transform]="getCharacterTransform(char)"
               >
                  <!-- Sprite - Real Pixel Art or Fallback -->
                  <div class="relative group pointer-events-auto cursor-pointer" (click)="onInteractCharacter(char)">
                    <!-- Shadow -->
                    <div class="absolute -bottom-3 left-1/2 -translate-x-1/2 w-24 h-6 bg-black/50 blur-lg rounded-[100%]"></div>
                    
                    <!-- Character Sprite Rendering -->
                    @if (isSpriteSheet(char)) {
                       <!-- ANIMATED SPRITE SHEET -->
                       <div class="pixel-sprite" [ngStyle]="getSpriteStyle(char)"></div>
                    } @else if (getCharacterSprite(char.name)) {
                      <!-- STATIC SPRITE IMAGE -->
                      <img 
                        [src]="getCharacterSprite(char.name)" 
                        [alt]="char.name"
                        class="w-auto h-32 sm:h-40 object-contain pixel-sprite drop-shadow-2xl"
                        [class.animate-bounce]="char.status === 'panic'"
                        [style.transform]="getFlipTransform(char)"
                      >
                    } @else {
                      <!-- Fallback Placeholder for characters without sprites -->
                      <div 
                        class="w-16 h-32 sm:w-20 sm:h-40 bg-gradient-to-b rounded-lg border-3 border-black/30 shadow-2xl relative overflow-hidden"
                        [class.from-cyan-600]="char.isPlayer"
                        [class.to-cyan-800]="char.isPlayer"
                        [class.from-orange-600]="!char.isPlayer"
                        [class.to-orange-800]="!char.isPlayer"
                        [class.animate-bounce]="char.status === 'panic'"
                        [style.transform]="getFlipTransform(char)"
                      >
                        <!-- Head (Bigger) -->
                        <div class="w-full h-1/3 bg-gradient-to-b from-white/30 to-white/10 top-0 absolute rounded-t-lg"></div>
                        <!-- Face/Visor -->
                        <div class="w-3/4 h-1/6 bg-black/50 top-4 left-1/2 -translate-x-1/2 absolute rounded-full"></div>
                        <!-- Body Details -->
                        <div class="absolute bottom-2 left-1/2 -translate-x-1/2 w-1/2 h-1/3 bg-white/10 rounded"></div>
                      </div>
                    }

                  </div>
               </div>
            }
          </div>
        }


        <!-- Room Label - Top Left -->

        <!-- Dialogue Options Overlay (Centered on Scene) -->
        @if (state()?.dialogueOptions?.length) {
          <div class="absolute inset-0 z-50 bg-black/80 backdrop-blur-sm flex flex-col items-center justify-center p-6 animate-in fade-in duration-300">
             <h3 class="text-amber-400 font-bold mb-4 tracking-widest uppercase text-lg border-b-2 border-amber-500/50 pb-2">Choose Response</h3>
             <div class="flex flex-col gap-3 w-full max-w-2xl">
               @for (option of state()?.dialogueOptions; track option.id) {
                 <button 
                    (click)="onDialogue(option)"
                    class="bg-gradient-to-r from-slate-800 to-slate-900 hover:from-amber-900 hover:to-amber-900 text-slate-200 hover:text-white border-l-4 border-amber-600 hover:border-amber-400 p-4 text-left transition-all duration-200 shadow-lg group rounded-r-lg"
                 >
                   <span class="text-sm text-amber-500 group-hover:text-amber-300 mr-2 font-bold">â–¶</span>
                   <span class="font-serif text-base">{{ option.label }}</span>
                 </button>
               }
             </div>
          </div>
        }
      </div>
    </div>
  </div>
  `,
  styles: [`
    .pixel-sprite {
      image-rendering: pixelated;
    }
    
    /* Custom Scrollbar - LucasArts Style */
    .custom-scrollbar::-webkit-scrollbar {
      width: 8px;
    }
    .custom-scrollbar::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.3);
      border-radius: 4px;
    }
    .custom-scrollbar::-webkit-scrollbar-thumb {
      background: rgba(245, 158, 11, 0.5);
      border-radius: 4px;
    }
    .custom-scrollbar::-webkit-scrollbar-thumb:hover {
      background: rgba(245, 158, 11, 0.7);
    }
  `]
})
export class ViewportComponent {
  state = input<GameState | null>(null);
  imageSrc = input<string>('');
  loading = input<boolean>(false);

  interact = output<PointOfInterest>();
  dialogueChoice = output<DialogueOption>();

  // Animation System
  // Globale clock per sincronizzare le animazioni
  private animFrame = signal<number>(0);
  private animationLoop: any;
  private cdr = inject(ChangeDetectorRef);

  private tickCount = 0;

  // Computed: Get correct hotspots for current scene
  currentHotspots = computed(() => {
    const s = this.state();
    if (s?.roomName === 'Test Room 01' || s?.flags?.['calibration_mode']) {
      return CALIBRATION_HOTSPOTS;
    }
    return BRIDGE_HOTSPOTS;
  });

  constructor() {
    // 30ms loop for ~30fps movement
    this.animationLoop = setInterval(() => {
      this.tickCount++;

      // Update character logic
      this.updateCharacterPositions();

      this.cdr.markForCheck();
    }, 30);
  }

  ngOnDestroy() {
    if (this.animationLoop) clearInterval(this.animationLoop);
  }

  onInteract(poi: PointOfInterest) {
    this.interact.emit(poi);
  }

  onSceneClick(event: MouseEvent) {
    // Solo se non c'Ã¨ un dialogo attivo
    if (this.state()?.dialogueOptions?.length) return;

    const container = event.currentTarget as HTMLElement;
    const rect = container.getBoundingClientRect();

    // Coordinate in percentuale (0-100)
    let x = ((event.clientX - rect.left) / rect.width) * 100;
    let y = ((event.clientY - rect.top) / rect.height) * 100;

    // DETERMINAZIONE AREA CAMMINABILE IN BASE ALLA STANZA
    const isCalibration = this.state()?.flags?.['calibration_mode'];

    if (isCalibration) {
      if (!isPointInCalibrationWalkableArea(x, y)) return;
    } else {
      if (!isPointInWalkableArea(x, y)) return;
    }

    // Controllo Collisioni con Oggetti (isObstacle)
    const hotspots = isCalibration ? CALIBRATION_HOTSPOTS : BRIDGE_HOTSPOTS;
    const isObstacle = hotspots.some(h =>
      h.isObstacle && (
        x >= h.bounds.x && x <= h.bounds.x + h.bounds.width &&
        y >= h.bounds.y && y <= h.bounds.y + h.bounds.height
      )
    );

    if (isObstacle) return;

    const player = this.state()?.characters.find(c => c.id === 'elias' || c.isPlayer);
    if (player) {
      player.targetPosition = { x, y };
    }
  }

  updateCharacterPositions() {
    const characters = this.state()?.characters;
    if (!characters) return;

    characters.forEach(char => {
      // Initialize walk distance if undefined
      if (char.walkDistance === undefined) char.walkDistance = 0;

      if (char.targetPosition) {
        const dx = char.targetPosition.x - (char.position?.x || 50);
        const dy = char.targetPosition.y - (char.position?.y || 50);
        const dist = Math.sqrt(dx * dx + dy * dy);

        // Soglia di arrivo piÃ¹ precisa per evitare "overshooting"
        if (dist < 0.3) {
          // Arrived - Interpolazione smooth verso la posizione finale
          if (char.position) {
            // Smooth final positioning per evitare salti visivi
            const smoothFactor = 0.3;
            char.position.x += (char.targetPosition.x - char.position.x) * smoothFactor;
            char.position.y += (char.targetPosition.y - char.position.y) * smoothFactor;

            // Quando siamo molto vicini, snap alla posizione finale
            if (Math.abs(char.targetPosition.x - char.position.x) < 0.1 &&
              Math.abs(char.targetPosition.y - char.position.y) < 0.1) {
              char.position.x = char.targetPosition.x;
              char.position.y = char.targetPosition.y;
              char.targetPosition = undefined;
              char.isMoving = false;
              char.walkDistance = 0; // Reset stride on stop
            }
          }
        } else {
          // Move
          const speed = 0.45; // Refined speed for natural pace
          const moveDist = Math.min(dist, speed);
          const ratio = moveDist / dist;

          if (!char.position) char.position = { x: 50, y: 50 };

          // Aggiornamento posizione con precisione migliorata
          const newX = char.position.x + (dx * ratio);
          const newY = char.position.y + (dy * ratio);

          char.position.x = newX;
          char.position.y = newY;

          char.isMoving = true;

          // Weighted distance: Y moves further in pixels than X for the same % unit (mobile aspect ratio)
          const visualDist = Math.sqrt(Math.pow(dx * ratio, 2) + Math.pow(dy * ratio * 1.6, 2));
          char.walkDistance += visualDist;

          // DETERMINATE FACING (4-Way) with vertical priority
          if (Math.abs(dy) > Math.abs(dx) * 0.8) {
            // Vertical movement (biased slightly to trigger sooner)
            if (dy > 0) char.facing = 'down';
            else char.facing = 'up';
            char.direction = dx > 0 ? 'right' : 'left';
          } else {
            // Horizontal dominant
            if (dx > 0) {
              char.facing = 'right';
              char.direction = 'right';
            } else {
              char.facing = 'left';
              char.direction = 'left';
            }
          }
        }
      } else {
        char.isMoving = false;
      }
    });

    // Update global animation frame based on time as fallback
    if (this.tickCount % 4 === 0) {
      this.animFrame.update(f => f + 1);
    }
  }

  // Gestisce i click sugli hotspots dell'immagine
  onHotspotInteract(hotspot: HotspotArea) {
    const poi: PointOfInterest = {
      id: hotspot.id,
      name: hotspot.name,
      description: hotspot.description,
      type: hotspot.type,
      status: hotspot.status
    };
    this.interact.emit(poi);
  }

  getCharacterTransform(char: GameCharacter): string {
    const y = char.position?.y || 50;

    // REGOLA DI PROFONDITÃ€ STABILIZZATA:
    // Evitiamo sbalzi eccessivi. Se Y=50 (centro), scala=1.
    // Range Y tipico calpestabile: 50 - 95.

    // Calcoliamo un progresso tra 40 e 100
    const progress = Math.max(0, Math.min(1, (y - 40) / 60));
    const depthScale = 0.8 + (progress * 0.45); // Range 0.8x (sfondo) a 1.25x (primo piano)

    const totalScale = (char.scale || 1) * depthScale;

    // Ancoraggio CONSISTENTE alla base (Piedi) al 100%
    // Questo garantisce che il personaggio sia sempre ancorato ai piedi,
    // indipendentemente dallo stato (movimento o idle)
    return `translate(-50%, -100%) scale(${totalScale})`;
  }

  getFlipTransform(char: GameCharacter): string {
    // Se lo sprite guarda a sinistra ma lo sprite base guarda a destra, flippiamo
    return char.direction === 'left' ? 'scaleX(-1)' : 'none';
  }

  onInteractCharacter(char: GameCharacter) {
    if (char.isPlayer) return;
    const poi: PointOfInterest = {
      id: char.id,
      name: char.name,
      description: char.name,
      type: 'character',
      status: 'unlocked'
    };
    this.interact.emit(poi);
  }

  // Determine if we should use sprite sheet rendering
  isSpriteSheet(char: GameCharacter): boolean {
    const name = (char.name || '').toLowerCase();
    const id = (char.id || '').toLowerCase();
    // Elias always uses his sheet
    if (name === 'elias' || id === 'elias') return true;
    return false;
  }

  getSpriteSheet(char: GameCharacter): string {
    if (char.name === 'Elias' || char.id === 'elias') return '/medico.PNG';
    return '';
  }

  // Calcola la posizione background-position per mostrare il frame giusto
  getSpriteStyle(char: GameCharacter): { [klass: string]: any } {
    if (!this.isSpriteSheet(char)) return {};

    const frameSize = 128;
    const framesPerRow = 8;
    const rowHeight = 256;

    let row = 1;
    let currentFrame = 0;
    let transformMultiplier = 'none';
    let verticalOffset = 0; // Offset per compensare differenze di altezza tra sprite

    if (char.isMoving) {
      // MOVIMENTO: 8 frame per riga
      const stride = 2.2; // Refined stride for speed 0.45 (Natural Walk)
      const walkDist = char.walkDistance || 0;
      currentFrame = Math.floor(walkDist / stride) % framesPerRow;

      switch (char.facing) {
        case 'right':
          row = 0; // Camminata Destra
          verticalOffset = 20; // Abbassiamo un po' la camminata
          break;
        case 'left':
          row = 0; // Camminata Destra fadi flippata
          transformMultiplier = 'scaleX(-1)';
          verticalOffset = 20; // Abbassiamo un po' la camminata
          break;
        case 'down':
          row = 1; // Camminata Avanti
          verticalOffset = 0;
          break;
        case 'up':
          row = 2; // Camminata Indietro
          verticalOffset = 0;
          break;
        default:
          row = 1;
          verticalOffset = 0;
      }
    } else {
      // IDLE STATE
      row = 3;
      // [CALIBRATED VALUE] Eseguito test con utente il 04/02/2026.
      // Offset di 90px Ã¨ PERFETTO per allineare lo sprite Idle ai piedi.
      // NON MODIFICARE senza test visivo.
      verticalOffset = 90;

      const globalFrame = this.animFrame();
      const cycleLength = 300; // Respiro ogni ~300 ticks (10s)
      const animLength = 8;

      const cyclePos = globalFrame % cycleLength;
      currentFrame = cyclePos < animLength ? cyclePos : 0;
    }

    const xPos = -(currentFrame * frameSize);
    const yPos = -(row * rowHeight);

    // Combina transform con offset verticale per mantenere i piedi ancorati
    const combinedTransform = verticalOffset !== 0
      ? `${transformMultiplier !== 'none' ? transformMultiplier + ' ' : ''}translateY(${verticalOffset}px)`
      : transformMultiplier;

    return {
      'width.px': frameSize,
      'height.px': rowHeight,
      'background-image': `url(${this.getSpriteSheet(char)})`,
      'background-size': '1024px auto',
      'background-position': `${xPos}px ${yPos}px`,
      'background-repeat': 'no-repeat',
      'transform': combinedTransform,
      // CRITICAL: transform-origin DEVE essere 'bottom center' per ancoraggio consistente ai piedi
      'transform-origin': 'bottom center',
      'image-rendering': 'pixelated'
    };
  }

  // Fallback old sprite getter
  getCharacterSprite(characterName: string): string | null {
    const sprites: { [key: string]: string } = {
      'Sarah': '/character-sarah.png',
      'Elias': '/character-elias.png', // Fallback se non usa sheet
      'Kael': '/character-kael.png',
      'Mina': '/character-mina.png'
    };
    return sprites[characterName] || null;
  }

  onDialogue(option: DialogueOption) {
    this.dialogueChoice.emit(option);
  }
}
